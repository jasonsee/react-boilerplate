'use strict';
var _ = require('ramda');
var Fluxxor = require('fluxxor');
var invertObject = require('helpers/invertObject');
var Promise = require('bluebird');


/**
 * promiseify
 *
 * @return {Function} A high order function that wraps resolved promises
 */
var promiseify = function() {
    return function(data) {
        return Promise.resolve(data);
    };
};

/**
 * Given a storeSpec with an array of mixins, and actions ie.
 * {
 *    mixins: [MixinOne, MixinTwo],
 *    normalActions: false,
 *    actions: { ... }
 * }
 *
 * execute `Fluxxor.createStore` on the result of using _.mixin on each of the Mixined
 * objects. MixinOne will not overwrite things specified in the Base Store Spec, MixinTwo
 * will not overwrite things specified in the Mixin One spec.
 *
 * @param storeSpec The typical store specification you would pass into
 * `Fluxxor.createStore.`
 * @return the result of executing all the mixins specified in the store spec.
*/
 var createStore = function (storeSpec) {
    // dirty lazy imperative
    _.map(function (Mixin) {
        var mixin = Mixin;

        // If the mixin is a function, run it with the given storeSpec and then mixin
        // the result. _.result anyone?
        if (_.is(Function, mixin)) {
            mixin = Mixin(storeSpec);
        }

        storeSpec = _.merge(mixin, storeSpec);
    }, storeSpec.mixins || []);

    // Flip the actions hash so you can put your constants as your value and
    // action names as  your keys only if they don't other wise say so with
    // normalActions on their storeSpec
    if (!storeSpec.normalActions) {
        storeSpec.actions = invertObject(storeSpec.actions);
    } else if (_.is(Array, storeSpec.actions)) {
        // When actions are an Array, Tuxxor gets real
        var transformActions = _.reduce(function(memo, actions) {
            return _.mixin(generateActions(actions, storeSpec));
        }, {});
    }

    return Fluxxor.createStore(storeSpec);
};

var generateActions = function (actions, storeSpec) {
    var generate = _.reduce(function (memo, actionPair) {
        var [actionName, action] = actionPair;
        var dispatchToken;
        if (_.is(Function, action)) {
            return memo;
        } else if (action.type === 'promised') {
            dispatchToken = action.dispatchToken;
            var handlers = ['Started', 'Success', 'Failure', 'Complete'];
            var boundActions = _.map(function (handler) {
                var handlerName = actionName + handler;
                if (!storeSpec[handlerName]) {
                    // Hnalder wasn't defined!
                    storeSpec[handlerName] = _.identity;
                }

                return [dispatchToken + "_" + handler.toUpperCase(), handlerName];
            }, handlers);

            return _.concat(memo, boundActions);
        } else {
            dispatchToken = _.is(String, action) ? action : action.dispatchToken;

            if (!storeSpec[actionName] && dispatchToken) {
                storeSpec[actionName] = _.identity;
                window.console.warn("Tuxxor.createStore(...) autogenerated a handler for %s called %s",
                             dispatchToken, actionName);

                return _.append([dispatchToken, actionName]);
            }
        }
    }, []);

    return _.compose(_.fromPairs, generate, _.toPairs)(actions);
};

var promised = function (dispatchToken, action) {
    return {
        type: 'promised',
        dispatchToken: dispatchToken,
        action: action
    };
};

var sync = function (dispatchToken, action) {
    return {
        type: 'sync',
        dispatchToken: dispatchToken,
        action: action
    };
};

var auto = function (dispatchToken) {
    return sync(dispatchToken, _.identity);
};

var createActions = function (actions, prefix) {
    prefix = prefix || '';
    var create = _.map(function (actionPair) {
        // Action key is the key the action will be called with from a view
        // e.g. actions.categories.add
        //
        // Action is either a [String, function] or String, where the string
        // is the key that dispatched. And the function provides transformations
        // that run upon the data. The transformed data will then be the value
        // that gets dispatched.
        //
        // If the result of executing the data function is a promise. It will auto
        // dispatch "_STARTED, _SUCCESS, _FAILURE, and _COMPLETE" messages.
        var [actionKey, action] = actionPair;
        var dispatchToken;
        var actionHandler;

        if (_.is(Function, action)) {
            return [actionKey, action];
        } else if (_.is(Object, action)) {
            if (action.type === undefined) {
                return [actionKey, createActions(action)];
            }

            actionHandler = action.action;
            dispatchToken = action.dispatchToken;
        }

        var handler = function (data) {
            var result = actionHandler(data);

            if (action.type === 'promised') {
                this.dispatch(dispatchToken + "_STARTED", [data]);

                result.then((resolution) => {
                    this.dispatch(dispatchToken + "_SUCCESS", [resolution]);
                }).catch((rejection) => {
                    this.dispatch(dispatchToken + "_FAILURE", [rejection]);
                }).finally(() => {
                    this.dispatch(dispatchToken + "_COMPLETE");
                });
            } else {
                this.dispatch(prefix, result);
            }

            return result;
        };

        return [actionKey, handler];
    });

    return _.compose(_.fromPairs, create, _.toPairs)(actions);
};

module.exports = {
    createActions: createActions,
    createStore: createStore,
    promised: promised,
    sync: sync,
    auto: auto
};
